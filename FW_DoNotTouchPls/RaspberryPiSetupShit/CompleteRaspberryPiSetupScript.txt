#!/bin/bash
# Complete Raspberry Pi Setup for Drone Tracking System
# Run this script directly on the Raspberry Pi

set -e  # Exit on any error

echo "=== Drone Tracking System Setup ==="
echo "Setting up Raspberry Pi for direct compilation and execution..."

# Update system
echo "Updating system packages..."
sudo apt update && sudo apt upgrade -y

# Install development tools
echo "Installing development tools..."
sudo apt install -y build-essential git cmake
sudo apt install -y gcc g++ make
sudo apt install -y gdb valgrind  # Debugging tools

# Install WiringPi library
echo "Installing WiringPi library..."
if ! command -v gpio &> /dev/null; then
    cd /tmp
    git clone https://github.com/WiringPi/WiringPi.git
    cd WiringPi
    ./build
    echo "WiringPi installed successfully"
else
    echo "WiringPi already installed"
fi

# Configure serial port
echo "Configuring serial port..."
sudo sed -i 's/console=serial0,115200 //' /boot/cmdline.txt
sudo systemctl disable hciuart
echo "enable_uart=1" | sudo tee -a /boot/config.txt

# Configure GPIO and permissions
echo "Setting up GPIO permissions..."
sudo usermod -a -G gpio,spi,i2c,dialout pi

# Create udev rule for serial device
echo "Creating udev rules..."
sudo tee /etc/udev/rules.d/99-lidar-serial.rules > /dev/null <<EOF
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", SYMLINK+="lidar"
KERNEL=="ttyS0", SYMLINK+="lidar_primary"
EOF

# Reload udev rules
sudo udevadm control --reload-rules
sudo udevadm trigger

# Create project directory structure
echo "Creating project structure..."
cd /home/pi
mkdir -p drone_tracker/{src,include,logs,scripts,config}
cd drone_tracker

# Create main C++ source file
echo "Creating main source file..."
cat > src/main.cpp << 'EOF'
#include <iostream>
#include <wiringPi.h>
#include <wiringSerial.h>
#include <softPwm.h>
#include <cmath>
#include <vector>
#include <chrono>
#include <thread>
#include <fstream>
#include <algorithm>
#include <signal.h>

// GPIO Pin Definitions
#define SERVO_PIN 18        // Pan servo (PWM)
#define STEP_PIN 17         // Stepper motor step
#define DIR_PIN 27          // Stepper motor direction
#define ENABLE_PIN 22       // Stepper motor enable
#define LIDAR_SERIAL "/dev/ttyS0"  // Serial port for LiDAR

// System Constants
#define SERVO_MIN 50        // Minimum servo PWM value
#define SERVO_MAX 250       // Maximum servo PWM value
#define SERVO_CENTER 150    // Center position PWM value
#define STEPS_PER_REV 1600  // Stepper motor steps per revolution (with microstepping)
#define SCAN_STEP_ANGLE 5   // Degrees per scan step
#define MAX_TRACKING_DISTANCE 10000  // Maximum tracking distance in cm
#define MIN_TRACKING_DISTANCE 50     // Minimum tracking distance in cm
#define VELOCITY_BUFFER_SIZE 10      // Buffer size for velocity calculation

// System States
enum SystemState {
    INITIALIZING,
    SCANNING,
    TARGET_ACQUIRED,
    TRACKING,
    SEARCHING,
    ERROR_STATE
};

// Target Information Structure
struct Target {
    double distance;
    double angle;
    double velocity;
    std::chrono::steady_clock::time_point lastSeen;
    bool isValid;
    int confidence;
};

// Kalman Filter Structure
struct KalmanFilter {
    double x;      // Position estimate
    double v;      // Velocity estimate
    double P_x;    // Position uncertainty
    double P_v;    // Velocity uncertainty
    double Q;      // Process noise
    double R;      // Measurement noise
};

// Global flag for clean shutdown
volatile bool running = true;

void signalHandler(int signum) {
    std::cout << "\nShutdown signal received (" << signum << ")" << std::endl;
    running = false;
}

class DroneTracker {
private:
    int serialHandle;
    SystemState currentState;
    Target currentTarget;
    KalmanFilter positionFilter;
    KalmanFilter velocityFilter;
    
    // Position tracking
    double currentPanAngle;
    double currentTiltAngle;
    std::vector<double> distanceBuffer;
    std::vector<double> angleBuffer;
    std::vector<std::chrono::steady_clock::time_point> timeBuffer;
    
    // Background subtraction
    std::vector<double> backgroundDistances;
    std::vector<double> backgroundAngles;
    bool backgroundCaptured;
    
    // Logging
    std::ofstream logFile;

public:
    DroneTracker() : 
        serialHandle(-1),
        currentState(INITIALIZING),
        currentPanAngle(0.0),
        currentTiltAngle(0.0),
        backgroundCaptured(false) {
        
        // Initialize target
        currentTarget.isValid = false;
        currentTarget.confidence = 0;
        
        // Initialize Kalman filters
        initializeKalmanFilter(positionFilter);
        initializeKalmanFilter(velocityFilter);
        
        // Open log file with timestamp
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto tm = *std::localtime(&time_t);
        
        char filename[100];
        std::strftime(filename, sizeof(filename), "logs/tracking_%Y%m%d_%H%M%S.csv", &tm);
        logFile.open(filename);
        
        if (logFile.is_open()) {
            logFile << "timestamp,distance,angle,velocity,confidence,state" << std::endl;
        }
    }
    
    ~DroneTracker() {
        cleanup();
        if (logFile.is_open()) {
            logFile.close();
        }
    }
    
    // System initialization
    bool initialize() {
        std::cout << "Initializing Drone Tracking System..." << std::endl;
        
        // Initialize WiringPi
        if (wiringPiSetupGpio() == -1) {
            std::cerr << "Failed to initialize WiringPi. Make sure to run with sudo." << std::endl;
            return false;
        }
        
        // Setup GPIO pins
        pinMode(STEP_PIN, OUTPUT);
        pinMode(DIR_PIN, OUTPUT);
        pinMode(ENABLE_PIN, OUTPUT);
        
        // Enable stepper motor driver
        digitalWrite(ENABLE_PIN, LOW);  // Active low enable
        
        // Initialize servo PWM
        if (softPwmCreate(SERVO_PIN, SERVO_CENTER, 1000) != 0) {
            std::cerr << "Failed to initialize servo PWM" << std::endl;
            return false;
        }
        
        // Initialize LiDAR serial connection
        serialHandle = serialOpen(LIDAR_SERIAL, 115200);
        if (serialHandle < 0) {
            std::cerr << "Failed to open LiDAR serial connection: " << LIDAR_SERIAL << std::endl;
            std::cerr << "Make sure the LiDAR is connected and you have permissions." << std::endl;
            return false;
        }
        
        // Move to center position
        std::cout << "Moving to center position..." << std::endl;
        moveServoToAngle(0.0);
        moveTiltToAngle(0.0);
        
        std::cout << "System initialized successfully" << std::endl;
        currentState = SCANNING;
        return true;
    }
    
    // Main system loop
    void run() {
        while (running && currentState != ERROR_STATE) {
            switch (currentState) {
                case SCANNING:
                    performScan();
                    break;
                case TARGET_ACQUIRED:
                    lockOnTarget();
                    break;
                case TRACKING:
                    trackTarget();
                    break;
                case SEARCHING:
                    searchForTarget();
                    break;
                default:
                    currentState = ERROR_STATE;
                    break;
            }
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
        
        if (!running) {
            std::cout << "System stopped by user" << std::endl;
        } else {
            std::cout << "System stopped due to error" << std::endl;
        }
    }
    
private:
    // Initialize Kalman filter
    void initializeKalmanFilter(KalmanFilter& filter) {
        filter.x = 0.0;
        filter.v = 0.0;
        filter.P_x = 1000.0;  // High initial uncertainty
        filter.P_v = 1000.0;
        filter.Q = 0.1;       // Process noise
        filter.R = 5.0;       // Measurement noise
    }
    
    // Read distance from LiDAR sensor
    double readLidarDistance() {
        uint8_t buffer[9];
        int bytesRead = 0;
        int attempts = 0;
        const int maxAttempts = 100;
        
        // Look for frame header (0x59, 0x59)
        while (bytesRead < 2 && attempts < maxAttempts) {
            if (serialDataAvail(serialHandle)) {
                uint8_t byte = serialGetchar(serialHandle);
                if (bytesRead == 0 && byte == 0x59) {
                    buffer[0] = byte;
                    bytesRead = 1;
                } else if (bytesRead == 1 && byte == 0x59) {
                    buffer[1] = byte;
                    bytesRead = 2;
                } else {
                    bytesRead = 0;
                }
            } else {
                std::this_thread::sleep_for(std::chrono::microseconds(100));
                attempts++;
            }
        }
        
        if (attempts >= maxAttempts) {
            return -1.0;  // Timeout
        }
        
        // Read remaining 7 bytes
        for (int i = 2; i < 9; i++) {
            attempts = 0;
            while (!serialDataAvail(serialHandle) && attempts < maxAttempts) {
                std::this_thread::sleep_for(std::chrono::microseconds(100));
                attempts++;
            }
            if (attempts >= maxAttempts) {
                return -1.0;  // Timeout
            }
            buffer[i] = serialGetchar(serialHandle);
        }
        
        // Calculate checksum
        uint8_t checksum = 0;
        for (int i = 0; i < 8; i++) {
            checksum += buffer[i];
        }
        
        if (checksum != buffer[8]) {
            return -1.0;  // Invalid reading
        }
        
        // Extract distance (little endian)
        uint16_t distance = buffer[2] | (buffer[3] << 8);
        
        // Convert to centimeters and validate
        if (distance < MIN_TRACKING_DISTANCE || distance > MAX_TRACKING_DISTANCE) {
            return -1.0;  // Out of range
        }
        
        return static_cast<double>(distance);
    }
    
    // Move servo to specified angle (-90 to +90 degrees)
    void moveServoToAngle(double angle) {
        // Clamp angle to valid range
        angle = std::max(-90.0, std::min(90.0, angle));
        
        // Convert angle to PWM value
        int pwmValue = SERVO_CENTER + static_cast<int>((angle / 90.0) * (SERVO_MAX - SERVO_CENTER));
        pwmValue = std::max(SERVO_MIN, std::min(SERVO_MAX, pwmValue));
        
        softPwmWrite(SERVO_PIN, pwmValue);
        currentPanAngle = angle;
        
        // Allow time for servo to move
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
    
    // Move tilt stepper motor to specified angle
    void moveTiltToAngle(double angle) {
        // Clamp angle to valid range
        angle = std::max(-45.0, std::min(45.0, angle));
        
        // Calculate required steps
        double deltaAngle = angle - currentTiltAngle;
        int steps = static_cast<int>((deltaAngle / 360.0) * STEPS_PER_REV);
        
        if (steps == 0) return;
        
        // Set direction
        digitalWrite(DIR_PIN, steps > 0 ? HIGH : LOW);
        steps = abs(steps);
        
        // Step the motor
        for (int i = 0; i < steps && running; i++) {
            digitalWrite(STEP_PIN, HIGH);
            std::this_thread::sleep_for(std::chrono::microseconds(500));
            digitalWrite(STEP_PIN, LOW);
            std::this_thread::sleep_for(std::chrono::microseconds(500));
        }
        
        currentTiltAngle = angle;
    }
    
    // Perform systematic scan for targets
    void performScan() {
        static double scanAngle = -90.0;
        static bool scanDirection = true;  // true = right, false = left
        
        std::cout << "Scanning at angle: " << scanAngle << std::endl;
        
        // Move to scan position
        moveServoToAngle(scanAngle);
        
        // Take multiple distance measurements for noise reduction
        std::vector<double> measurements;
        for (int i = 0; i < 5; i++) {
            double distance = readLidarDistance();
            if (distance > 0) {
                measurements.push_back(distance);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        
        if (!measurements.empty()) {
            // Calculate median distance
            std::sort(measurements.begin(), measurements.end());
            double medianDistance = measurements[measurements.size() / 2];
            
            // Log scan data
            logTrackingData(medianDistance, scanAngle, 0.0, "SCANNING");
            
            // Check for target
            if (isTargetDetected(medianDistance, scanAngle)) {
                currentTarget.distance = medianDistance;
                currentTarget.angle = scanAngle;
                currentTarget.lastSeen = std::chrono::steady_clock::now();
                currentTarget.isValid = true;
                currentTarget.confidence = 100;
                
                std::cout << "Target detected at distance: " << medianDistance 
                         << " cm, angle: " << scanAngle << std::endl;
                
                currentState = TARGET_ACQUIRED;
                return;
            }
        }
        
        // Update scan angle
        if (scanDirection) {
            scanAngle += SCAN_STEP_ANGLE;
            if (scanAngle >= 90.0) {
                scanDirection = false;
                scanAngle = 90.0;
            }
        } else {
            scanAngle -= SCAN_STEP_ANGLE;
            if (scanAngle <= -90.0) {
                scanDirection = true;
                scanAngle = -90.0;
            }
        }
    }
    
    // Check if current measurement indicates a target
    bool isTargetDetected(double distance, double angle) {
        // First pass - capture background if not done
        if (!backgroundCaptured) {
            backgroundDistances.push_back(distance);
            backgroundAngles.push_back(angle);
            
            if (backgroundDistances.size() >= 36) {  // Complete 180° scan
                backgroundCaptured = true;
                std::cout << "Background capture completed" << std::endl;
            }
            return false;
        }
        
        // Find closest background measurement
        double minAngleDiff = std::abs(angle - backgroundAngles[0]);
        int closestIndex = 0;
        
        for (size_t i = 1; i < backgroundAngles.size(); i++) {
            double angleDiff = std::abs(angle - backgroundAngles[i]);
            if (angleDiff < minAngleDiff) {
                minAngleDiff = angleDiff;
                closestIndex = i;
            }
        }
        
        // Check for significant difference from background
        double backgroundDistance = backgroundDistances[closestIndex];
        double distanceDiff = std::abs(distance - backgroundDistance);
        
        // Target detection criteria
        bool withinRange = (distance >= MIN_TRACKING_DISTANCE && distance <= MAX_TRACKING_DISTANCE);
        bool significantChange = (distanceDiff > 100.0);  // 1 meter difference
        bool closerThanBackground = (distance < backgroundDistance - 50.0);  // Target is closer
        
        return withinRange && significantChange && closerThanBackground;
    }
    
    // Lock onto detected target
    void lockOnTarget() {
        std::cout << "Locking onto target..." << std::endl;
        
        // Center the target in field of view
        moveServoToAngle(currentTarget.angle);
        
        // Take more precise measurements
        std::vector<double> measurements;
        for (int i = 0; i < 10; i++) {
            double distance = readLidarDistance();
            if (distance > 0) {
                measurements.push_back(distance);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
        }
        
        if (measurements.size() >= 5) {
            // Calculate average distance
            double avgDistance = 0.0;
            for (double d : measurements) {
                avgDistance += d;
            }
            avgDistance /= measurements.size();
            
            // Update target information
            currentTarget.distance = avgDistance;
            currentTarget.angle = currentPanAngle;
            currentTarget.velocity = 0.0;  // Will be calculated during tracking
            
            // Initialize tracking buffers
            distanceBuffer.clear();
            angleBuffer.clear();
            timeBuffer.clear();
            
            std::cout << "Target locked at distance: " << avgDistance << " cm" << std::endl;
            currentState = TRACKING;
        } else {
            std::cout << "Failed to lock onto target, returning to scan" << std::endl;
            currentState = SCANNING;
        }
    }
    
    // Active target tracking
    void trackTarget() {
        auto currentTime = std::chrono::steady_clock::now();
        double distance = readLidarDistance();
        
        if (distance < 0) {
            // Lost target
            currentTarget.confidence -= 10;
            if (currentTarget.confidence <= 0) {
                std::cout << "Target lost, switching to search mode" << std::endl;
                currentState = SEARCHING;
            }
            return;
        }
        
        // Update confidence
        currentTarget.confidence = std::min(100, currentTarget.confidence + 5);
        currentTarget.lastSeen = currentTime;
        
        // Add to tracking buffers
        distanceBuffer.push_back(distance);
        angleBuffer.push_back(currentPanAngle);
        timeBuffer.push_back(currentTime);
        
        // Maintain buffer size
        if (distanceBuffer.size() > VELOCITY_BUFFER_SIZE) {
            distanceBuffer.erase(distanceBuffer.begin());
            angleBuffer.erase(angleBuffer.begin());
            timeBuffer.erase(timeBuffer.begin());
        }
        
        // Calculate target velocity if we have enough data
        if (distanceBuffer.size() >= 3) {
            calculateTargetVelocity();
        }
        
        // Simple tracking adjustment (can be enhanced with Kalman filter)
        double targetAngle = currentPanAngle;  // Basic assumption for now
        
        // Log tracking data
        logTrackingData(distance, currentPanAngle, currentTarget.velocity, "TRACKING");
        
        std::cout << "Tracking - Distance: " << distance 
                 << " cm, Angle: " << currentPanAngle 
                 << ", Confidence: " << currentTarget.confidence << "%" << std::endl;
    }
    
    // Calculate target velocity using recent position data
    void calculateTargetVelocity() {
        if (distanceBuffer.size() < 2) return;
        
        // Simple velocity calculation using last two points
        auto timeDiff = std::chrono::duration_cast<std::chrono::milliseconds>(
            timeBuffer.back() - timeBuffer[timeBuffer.size() - 2]).count();
        
        if (timeDiff > 0) {
            double distanceDiff = distanceBuffer.back() - distanceBuffer[distanceBuffer.size() - 2];
            currentTarget.velocity = (distanceDiff / timeDiff) * 1000.0;  // cm/s
        }
    }
    
    // Search for lost target
    void searchForTarget() {
        static double searchAngle = currentTarget.angle;
        static double searchRadius = 10.0;  // Start with small search radius
        static int searchStep = 0;
        
        std::cout << "Searching for target around angle: " << searchAngle 
                 << " with radius: " << searchRadius << std::endl;
        
        // Implement spiral search pattern
        double currentSearchAngle = searchAngle + searchRadius * std::sin(searchStep * 0.5);
        currentSearchAngle = std::max(-90.0, std::min(90.0, currentSearchAngle));
        
        moveServoToAngle(currentSearchAngle);
        
        // Take measurement
        double distance = readLidarDistance();
        if (distance > 0 && isTargetDetected(distance, currentSearchAngle)) {
            // Target reacquired
            currentTarget.distance = distance;
            currentTarget.angle = currentSearchAngle;
            currentTarget.confidence = 50;  // Reduced confidence initially
            currentTarget.lastSeen = std::chrono::steady_clock::now();
            
            std::cout << "Target reacquired!" << std::endl;
            currentState = TRACKING;
            
            // Reset search parameters
            searchRadius = 10.0;
            searchStep = 0;
            return;
        }
        
        // Update search parameters
        searchStep++;
        if (searchStep > 20) {  // Expand search after full spiral
            searchRadius += 5.0;
            searchStep = 0;
            
            if (searchRadius > 45.0) {  // Give up and return to full scan
                std::cout << "Search failed, returning to scan mode" << std::endl;
                currentState = SCANNING;
                searchRadius = 10.0;
            }
        }
    }
    
    // Log tracking data to file
    void logTrackingData(double distance, double angle, double velocity, const std::string& state) {
        if (logFile.is_open()) {
            auto now = std::chrono::steady_clock::now();
            auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                now.time_since_epoch()).count();
            
            logFile << timestamp << "," << distance << "," << angle << "," 
                   << velocity << "," << currentTarget.confidence << "," << state << std::endl;
            logFile.flush();  // Ensure data is written
        }
    }
    
    // System cleanup
    void cleanup() {
        std::cout << "Cleaning up system..." << std::endl;
        
        // Disable stepper motor
        digitalWrite(ENABLE_PIN, HIGH);
        
        // Center servo
        moveServoToAngle(0.0);
        
        // Close serial connection
        if (serialHandle >= 0) {
            serialClose(serialHandle);
        }
    }
};

// Main function
int main() {
    std::cout << "=== Drone Tracking System v1.0 ===" << std::endl;
    std::cout << "Designed for satellite tracking applications" << std::endl;
    std::cout << "Press Ctrl+C to stop the system" << std::endl << std::endl;
    
    // Set up signal handlers
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);
    
    DroneTracker tracker;
    
    if (!tracker.initialize()) {
        std::cerr << "Failed to initialize tracking system" << std::endl;
        return -1;
    }
    
    std::cout << "Starting tracking system..." << std::endl;
    
    try {
        tracker.run();
    } catch (const std::exception& e) {
        std::cerr << "System error: " << e.what() << std::endl;
        return -1;
    }
    
    std::cout << "System shutdown complete." << std::endl;
    return 0;
}
EOF

# Create Makefile
echo "Creating Makefile..."
cat > Makefile << 'EOF'
# Makefile for Drone Tracking System
CXX = g++
CXXFLAGS = -std=c++11 -Wall -Wextra -O2 -pthread
INCLUDES = -I./include
LIBS = -lwiringPi -lpthread

TARGET = drone_tracker
SRCDIR = src
OBJDIR = obj
SOURCES = $(wildcard $(SRCDIR)/*.cpp)
OBJECTS = $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)

# Create obj directory if it doesn't exist
$(shell mkdir -p $(OBJDIR))

.PHONY: all clean install run debug status stop logs

all: $(TARGET)

$(TARGET): $(OBJECTS)
	$(CXX) $(OBJECTS) -o $@ $(LIBS)
	@echo "Build complete. Use 'make run' to start the system."

$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

clean:
	rm -rf $(OBJDIR) $(TARGET)
	@echo "Clean complete."

install: $(TARGET)
	sudo cp $(TARGET) /usr/local/bin/
	sudo chmod +x /usr/local/bin/$(TARGET)
	@echo "System installed to /usr/local/bin/"

run: $(TARGET)
	@echo "Starting drone tracking system..."
	@echo "Press Ctrl+C to stop"
	sudo ./$(TARGET)

debug: CXXFLAGS += -DDEBUG -g
debug: clean $(TARGET)
	@echo "Debug build complete. Use 'sudo gdb ./$(TARGET)' to debug."

# Hardware test commands
test-servo:
	@echo "Testing servo movement..."
	gpio mode 18 pwm
	gpio pwm 18 150
	sleep 1
	gpio pwm 18 50
	sleep 1
	gpio pwm 18 250
	sleep 1
	gpio pwm 18 150
	@echo "Servo test complete."

test-stepper:
	@echo "Testing stepper motor..."
	gpio mode 17 out
	gpio mode 27 out
	gpio mode 22 out
	gpio write 22 0
	gpio write 27 1
	@for i in $$(seq 1 100); do \
		gpio write 17 1; \
		sleep 0.001; \
		gpio write 17 0; \
		sleep 0.001; \
	done
	@echo "Stepper test complete."

test-hardware: test-servo test-stepper

# System status and control
status:
	@echo "=== System Status ==="
	@if pgrep -f drone_tracker > /dev/null; then \
		echo "✓ Tracking system is running (PID: $$(pgrep -f drone_tracker))"; \
	else \
		echo "✗ Tracking system is not running"; \
	fi
	@if [ -e /dev/ttyS0 ]; then \
		echo "✓ Serial port available"; \
	else \
		echo "✗ Serial port not found"; \
	fi
	@if gpio -v &>/dev/null; then \
		echo "✓ WiringPi available"; \
	else \
		echo "✗ WiringPi not found"; \
	fi

stop:
	@echo "Stopping tracking system..."
	@if pgrep -f drone_tracker > /dev/null; then \
		sudo pkill -SIGINT -f drone_tracker; \
		echo "Stop signal sent."; \
	else \
		echo "System is not running."; \
	fi

logs:
	@echo "Recent log files:"
	@ls -la logs/*.csv 2>/dev/null || echo "No log files found"
	@echo ""
	@echo "To view latest log: tail -f logs/tracking_*.csv"

help:
	@echo "Available commands:"
	@echo "  make          - Compile the system"
	@echo "  make run      - Compile and run the system"
	@echo "  make debug    - Compile with debug symbols"
	@echo "  make clean    - Clean build files"
	@echo "  make install  - Install to system PATH"
	@echo "  make status   - Show system status"
	@echo "  make stop     - Stop running system"
	@echo "  make logs     - Show available log files"
	@echo "  make test-hardware - Test servo and stepper"
	@echo "  make help     - Show this help"
EOF

# Create startup script
echo "Creating startup script..."
cat > scripts/start_tracker.sh << 'EOF'
#!/bin/bash
# Startup script for drone tracker

cd /home/pi/drone_tracker

echo "=== Drone Tracker Startup ==="
echo "Checking system prerequisites..."

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "This script must be run with sudo"
    exit 1
fi

# Check hardware connections
if [ ! -e /dev/ttyS0 ]; then
    echo "Warning: Serial port /dev/ttyS0 not found"
    echo "Make sure LiDAR is connected"
fi

# Check WiringPi
if ! gpio -v &>/dev/null; then
    echo "Error: WiringPi not found"
    exit 1
fi

# Build if necessary
if [ ! -f drone_tracker ]; then
    echo "Building system..."
    make clean && make
fi

# Start the tracker
echo "Starting drone tracking system..."
exec ./drone_tracker
EOF

chmod +x scripts/start_tracker.sh

# Create system service
echo "Creating systemd service..."
sudo tee /etc/systemd/system/drone-tracker.service > /dev/null <<EOF
[Unit]
Description=Drone Tracking System
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/home/pi/drone_tracker
ExecStart=/home/pi/drone_tracker/scripts/start_tracker.sh
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

# Reload systemd
sudo systemctl daemon-reload

# Create quick access scripts
echo "Creating control scripts..."
cat > quick-start.sh << 'EOF'
#!/bin/bash
echo "=== Quick Start Drone Tracker ==="
cd /home/pi/drone_tracker
make run
EOF

cat > quick-stop.sh << 'EOF'
#!/bin/bash
echo "=== Stopping Drone Tracker ==="
cd /home/pi/drone_tracker
make stop
EOF

cat > quick-status.sh << 'EOF'
#!/bin/bash
echo "=== Drone Tracker Status ==="
cd /home/pi/drone_tracker
make status
EOF

cat > quick-logs.sh << 'EOF'
#!/bin/bash
echo "=== Drone Tracker Logs ==="
cd /home/pi/drone_tracker
make logs
echo ""
echo "Choose a log file to view:"
select log in logs/*.csv; do
    if [ -n "$log" ]; then
        echo "Viewing $log (press Ctrl+C to exit):"
        tail -f "$log"
    fi
    break
done
EOF

chmod +x quick-*.sh

# Set proper ownership
chown -R pi:pi /home/pi/drone_tracker

echo ""
echo "=== Setup Complete ==="
echo ""
echo "The drone tracking system has been set up successfully!"
echo ""
echo "Quick Commands:"
echo "  ./quick-start.sh   - Start the tracking system"
echo "  ./quick-stop.sh    - Stop the tracking system"  
echo "  ./quick-status.sh  - Check system status"
echo "  ./quick-logs.sh    - View log files"
echo ""
echo "Advanced Commands:"
echo "  make run          - Compile and run"
echo "  make status       - System status"
echo "  make test-hardware - Test motors and sensors"
echo ""
echo "Service Commands:"
echo "  sudo systemctl start drone-tracker    - Start as service"
echo "  sudo systemctl stop drone-tracker     - Stop service"
echo "  sudo systemctl enable drone-tracker   - Auto-start on boot"
echo "  sudo journalctl -u drone-tracker -f   - View service logs"
echo ""
echo "IMPORTANT: System requires sudo privileges to access GPIO"
echo "REBOOT REQUIRED for serial port changes to take effect"
echo ""
read -p "Reboot now? (y/n): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    sudo reboot
fi