import numpy as np
import math

def predict_ellipse_trajectory(detected_points_polar):
    """
    Predicts the next point on a trajectory by fitting an ellipse to five detected points.

    Args:
        detected_points_polar (list): A list of 5 tuples, each containing (angle, distance).
                                      Angle is in degrees, distance is in cm.

    Returns:
        tuple: A tuple (predicted_angle, predicted_distance) for the next point,
               or (None, None) if the process fails.
    """
    if len(detected_points_polar) < 5:
        print("Error: At least 5 points are required to fit an ellipse.")
        return None, None

    # Step 1: Convert polar coordinates to Cartesian coordinates (x, y)
    print("Converting polar coordinates to Cartesian...")
    cartesian_points = np.array([
        (dist * math.cos(math.radians(angle)), dist * math.sin(math.radians(angle)))
        for angle, dist in detected_points_polar
    ])
    print("Cartesian points:\n", cartesian_points)

    # Step 2: Fit an ellipse to the Cartesian points
    print("\nFitting an ellipse to the points...")
    x = cartesian_points[:, 0]
    y = cartesian_points[:, 1]
    D = np.vstack([x**2, x*y, y**2, x, y, np.ones(len(x))]).T
    
    U, S, V = np.linalg.svd(D, full_matrices=False)
    coeffs = V[-1, :]
    
    A, B, C = coeffs[0], coeffs[1], coeffs[2]
    if B**2 - 4 * A * C >= 0:
        print("Warning: The fitted conic is not an ellipse.")
        return None, None
    print("Ellipse coefficients (A, B, C, D, E, F):\n", coeffs)
    

    # Step 3: Predict the next point along the trajectory
    print("\nPredicting the next point...")
    last_stepper_angle = detected_points_polar[-1][0]
    PREDICTION_STEP_ANGLE = 2.0  # degrees
    next_stepper_angle = last_stepper_angle + PREDICTION_STEP_ANGLE
    angle_rad = math.radians(next_stepper_angle)
    
    a = A * math.cos(angle_rad)**2 + B * math.cos(angle_rad) * math.sin(angle_rad) + C * math.sin(angle_rad)**2
    b = coeffs[3] * math.cos(angle_rad) + coeffs[4] * math.sin(angle_rad)
    c = coeffs[5]
    
    discriminant = b**2 - 4 * a * c
    
    if discriminant < 0:
        print("Prediction failed: No real solution for the next point.")
        return None, None
    
    predicted_distance = (-b + math.sqrt(discriminant)) / (2 * a)
    
    print("\nðŸŽ‰ Prediction Successful! ðŸŽ‰")
    return next_stepper_angle, predicted_distance

# Example Usage:
if __name__ == "__main__":
    # Sample input of 5 detected points
    detected_points = [
        (40.0, 100.0),
        (45.0, 95.0),
        (50.0, 88.0),
        (55.0, 80.0),
        (60.0, 75.0)
    ]
    
    predicted_angle, predicted_distance = predict_ellipse_trajectory(detected_points)

    if predicted_angle is not None:
        print(f"Predicted Angle: {predicted_angle:.2f} degrees")
        print(f"Predicted Distance: {predicted_distance:.2f} cm")
