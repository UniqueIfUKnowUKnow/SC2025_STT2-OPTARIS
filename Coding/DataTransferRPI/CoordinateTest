# Import necessary libraries.
import asyncio      # For running asynchronous code (handling multiple things at once).
import websockets   # The library for creating WebSocket servers and clients.
import json         # For converting Python dictionaries to JSON strings, a standard format for web data.
import random       # For generating random numbers for our coordinates.
import signal       # (Not used in this version but good for handling shutdown signals gracefully).

# --- Global Variable ---
# A 'set' is used to store all active client connections.
# A set is efficient for adding and removing items, and it automatically handles duplicates.
CONNECTED_CLIENTS = set()


# --- Asynchronous Function Definitions ---

async def data_producer():
    """
    This function runs in an infinite loop, acting as the data generator.
    It creates random XYZ coordinates and sends them to all connected clients.
    """
    # 'while True' creates a loop that runs forever until the program is stopped.
    while True:
        try:
            # Create a Python dictionary to hold the coordinates.
            point = {
                # 'random.uniform(-10, 10)' generates a random floating-point number between -10 and 10.
                # 'round(..., 2)' rounds the number to two decimal places for cleaner data.
                "x": round(random.uniform(-10, 10), 2),
                "y": round(random.uniform(-10, 10), 2),
                "z": round(random.uniform(-5, 5), 2),
            }

            # Convert the Python dictionary into a JSON formatted string.
            # e.g., {'x': 1.23, 'y': -4.56} becomes '{"x": 1.23, "y": -4.56}'
            message = json.dumps(point)

            # Check if there are any clients connected before trying to send data.
            if CONNECTED_CLIENTS:
                # This is an efficient way to send the message to all clients at once.
		# Use asyncio.gather() to run all 'send' operations concurrently.
                # The asterisk (*) unpacks the list of send tasks.

               await asyncio.gather(*[client.send(message) for client in CONNECTED_CLIENTS])
           
	 # 'await asyncio.sleep(0.1)' pauses this function for 0.1 seconds.
            # This controls the rate of data generation (10 points per second).
            # It's an 'await' call, so it doesn't block the rest of the program.
            await asyncio.sleep(0.1)

        # A general 'except' block to catch any errors that might occur in the loop.
        except Exception as e:
            print(f"Error in data producer: {e}")
            # If an error occurs, wait for 1 second before trying again.
            await asyncio.sleep(1)


async def connection_handler(websocket):
    """
    This function is called automatically by the websockets library
    every time a new client connects to the server.
    """
    # Print the IP address and port of the newly connected client for logging purposes.
    print(f"Client connected: {websocket.remote_address}")
    # Add the new client's connection object to our global set of clients.
    CONNECTED_CLIENTS.add(websocket)
    try:
        # This is the main part of the handler. It simply waits until the client disconnects.
        # The 'data_producer' function is responsible for sending data, so this handler just needs to maintain the connection.
        await websocket.wait_closed()
    finally:
        # This 'finally' block ensures that the client is removed from our set
        # no matter how the connection was closed (normally, with an error, etc.).
        print(f"Client disconnected: {websocket.remote_address}")
        CONNECTED_CLIENTS.remove(websocket)


async def main():
    """
    The main function that sets up and starts the server and data producer.
    """
    # 'asyncio.create_task()' schedules the 'data_producer' function to run in the background.
    # It starts running as soon as the asyncio event loop starts.
    producer_task = asyncio.create_task(data_producer())

    # 'websockets.serve' starts the WebSocket server.
    # It listens on all available network interfaces ("0.0.0.0") on port 8765.
    # It registers 'connection_handler' to be called for each new connection.
    server = await websockets.serve(connection_handler, "0.0.0.0", 8765)

    print("WebSocket server started and is broadcasting data...")

    # This line will pause the 'main' function indefinitely, keeping the server alive.
    # The server will run until it's manually stopped (e.g., with Ctrl+C).
    await server.wait_closed()
    # When the server is closed, we also cancel the background producer task.
    producer_task.cancel()


# --- Script Entry Point ---
# This standard Python construct ensures the code inside only runs when the script is executed directly.
if __name__ == "__main__":
    try:
        # 'asyncio.run()' starts the asyncio event loop and runs the 'main' function.
        # This is the command that kicks everything off.
        asyncio.run(main())
    except KeyboardInterrupt:
        # This catches the Ctrl+C command from the user.
        # It allows the program to print a clean shutdown message instead of a messy error.
        print("\nServer is shutting down.")
