# Import necessary libraries from system, numpy, PyQt, pyqtgraph, and websockets 

import sys 

import numpy as np 

from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, 

                             QLineEdit, QPushButton, QListWidget, QMessageBox, QGroupBox) 

from PyQt6.QtGui import QColor 

from PyQt6.QtCore import QThread, pyqtSignal  # QThread and pyqtSignal are crucial for background tasks 

import pyqtgraph.opengl as gl 

import websockets 

import asyncio 

import json 

import signal

 
 

# --- New WebSocket Client Thread --- 

# This class handles all network communication in the background. 

class WebSocketClientThread(QThread): 

    """ 

    Runs the WebSocket client in a separate thread to avoid freezing the UI. 

    It continuously listens for messages from the server and emits a signal 

    when new data arrives. 

    """ 

    # Define a custom signal. This signal will be emitted with a dictionary payload (the coordinate data). 

    # It acts as a safe bridge from this background thread to the main UI thread. 

    newDataReceived = pyqtSignal(dict) 

 
 

    def __init__(self, uri): 

        """ 

        Initializes the thread. 

        Args: 

            uri (str): The WebSocket server address (e.g., "ws://192.168.55.180:8765"). 

        """ 

        super().__init__() 

        self.uri = uri 

 
 

    async def connect_and_listen(self): 

        """ 

        The main asynchronous loop for connecting and receiving messages. 

        This will run forever, trying to maintain a connection. 

        """ 

        # An infinite loop to ensure the client always tries to reconnect if the connection drops. 

        while True: 

            try: 

                # The 'async with' statement handles opening and closing the connection. 

                async with websockets.connect(self.uri) as websocket: 

                    print("Successfully connected to the Raspberry Pi server.") 

                    # This loop waits for and processes each message as it arrives from the server. 

                    async for message in websocket: 

                        try: 

                            # The server sends data as a JSON string. We parse it into a Python dictionary. 

                            data = json.loads(message) 

                            # Emit the signal, sending the parsed data dictionary to the main UI thread. 

                            self.newDataReceived.emit(data) 

                        except json.JSONDecodeError: 

                            # Handle cases where the received message is not valid JSON. 

                            print(f"Could not decode JSON: {message}") 

 
 

            # Handle specific connection errors. 

            except (websockets.exceptions.ConnectionClosedError, ConnectionRefusedError) as e: 

                print(f"Connection lost or refused: {e}. Retrying in 3 seconds...") 

                # Wait for 3 seconds before attempting to reconnect to avoid spamming connection requests. 

                await asyncio.sleep(3) 

            except Exception as e: 

                # Catch any other unexpected errors. 

                print(f"An unexpected error occurred: {e}. Retrying in 3 seconds...") 

                await asyncio.sleep(3) 

 
 

    def run(self): 

        """ 

        This method is automatically executed when the thread starts via `self.client_thread.start()`. 

        """ 

        # `asyncio.run()` starts the asynchronous event loop defined in `connect_and_listen`. 

        # This is the entry point for the background thread's work. 

        asyncio.run(self.connect_and_listen()) 

 
 
 

# --- Main Application Window --- 

class SatelliteTracker3D(QWidget): 

    def __init__(self): 

        super().__init__() 

        self.setWindowTitle("Live Satellite Tracker 3D") 

        self.setGeometry(100, 100, 1200, 800) 

 
 

        # Initialize lists to store the raw point data 

        self.points = [] 

        self.predicted_points = [] 

         

        # Set up the UI elements (buttons, lists, etc.) 

        self.init_ui() 

        # Set up the 3D plotting area 

        self.init_gl() 

        # Create and start the background WebSocket client thread 

        self.init_websocket_client() 

 
 

    def init_ui(self): 

        # This method builds the layout and widgets of the control panel. 

        # It's mostly unchanged from your original code. 

        main_layout = QHBoxLayout(self) 

        control_panel = QVBoxLayout() 

        control_group = QGroupBox("Satellite Tracker Controls") 

        control_g_layout = QVBoxLayout() 

         

        input_group = QGroupBox("Add New Point Manually") 

        input_layout = QVBoxLayout() 

        self.input_x, self.input_y, self.input_z = QLineEdit(), QLineEdit(), QLineEdit() 

        input_layout.addWidget(QLabel("X:")), input_layout.addWidget(self.input_x) 

        input_layout.addWidget(QLabel("Y:")), input_layout.addWidget(self.input_y) 

        input_layout.addWidget(QLabel("Z:")), input_layout.addWidget(self.input_z) 

        btn_add = QPushButton("Add Manual Point") 

        btn_add.clicked.connect(self.on_add_manual_point) 

        input_layout.addWidget(btn_add) 

        input_group.setLayout(input_layout) 

 
 

        button_group = QGroupBox("Controls") 

        button_layout = QVBoxLayout() 

        self.btn_show_trajectory = QPushButton("Show Trajectory") 

        self.btn_show_trajectory.clicked.connect(self.on_show_trajectory) 

        self.btn_predict = QPushButton("Predict Path") 

        self.btn_predict.clicked.connect(self.on_predict_path) 

        self.btn_clear = QPushButton("Clear All") 

        self.btn_clear.setStyleSheet("background-color: LightCoral") 

        self.btn_clear.clicked.connect(self.on_clear_all) 

        button_layout.addWidget(self.btn_show_trajectory) 

        button_layout.addWidget(self.btn_predict) 

        button_layout.addWidget(self.btn_clear) 

        button_group.setLayout(button_layout) 

         

        list_group = QGroupBox("Tracked Points") 

        list_layout = QVBoxLayout() 

        self.list_points = QListWidget() 

        list_layout.addWidget(self.list_points) 

        list_group.setLayout(list_layout) 

 
 

        control_g_layout.addWidget(input_group) 

        control_g_layout.addWidget(button_group) 

        control_g_layout.addWidget(list_group) 

        control_group.setLayout(control_g_layout) 

        control_panel.addWidget(control_group) 

         

        main_layout.addLayout(control_panel, 0) 

         

        self.gl_view = gl.GLViewWidget() 

        self.gl_view.opts['distance'] = 40 

        main_layout.addWidget(self.gl_view, 1) 

 
 

        self.setLayout(main_layout) 

 
 

    def init_websocket_client(self): 

        """ 

        This new method creates an instance of our client thread and starts it. 

        """ 

        # IMPORTANT: Replace with your Raspberry Pi's actual IP address 

        pi_ip_address = "192.168.55.180"  

        uri = f"ws://{pi_ip_address}:8765" 

         

        # Create an instance of our background thread class. 

        self.client_thread = WebSocketClientThread(uri) 

         

        # **THIS IS THE KEY CONNECTION**: 

        # Connect the 'newDataReceived' signal from the thread to the 'add_point_from_network' slot (function) in this class. 

        # Now, whenever the thread emits the signal, the `add_point_from_network` method will be called safely. 

        self.client_thread.newDataReceived.connect(self.add_point_from_network) 

         

        # Start the thread. This will call the thread's `run()` method. 

        self.client_thread.start() 

 
 

    def add_point_from_network(self, data): 

        """ 

        This is the "slot" that is executed when the network thread emits a signal. 

        It safely updates the UI with the new data. 

        """ 

        try: 

            # Extract coordinate values from the received dictionary. 

            x, y, z = float(data['x']), float(data['y']), float(data['z']) 

            new_point = np.array([x, y, z]) 

            # Add the new numpy array to our list of points. 

            self.points.append(new_point) 

             

            # Update the QListWidget in the UI with the new point's coordinates. 

            self.list_points.addItem(f"Point {len(self.points)}: ({x:.2f}, {y:.2f}, {z:.2f})") 

            # Automatically scroll the list to ensure the latest point is always visible. 

            self.list_points.scrollToBottom() 

             

            # Add a visual representation (a sphere) of the new point to the 3D plot. 

            sphere = self.add_sphere(new_point, QColor(0, 255, 0)) 

            self.point_items.append(sphere) 

             

            # Automatically redraw the trajectory line to include the new point. 

            self.on_show_trajectory() 

 
 

        except (ValueError, KeyError) as e: 

            # Handle cases where the data dictionary is malformed. 

            print(f"Error processing received data: {e}") 

 
 

    def on_add_manual_point(self): 

        """Handles the "Add Manual Point" button click.""" 

        try: 

            # Read the text from the input fields. 

            x = float(self.input_x.text()) 

            y = float(self.input_y.text()) 

            z = float(self.input_z.text()) 

            # Reuse the same logic as the network handler to add the point to the UI. 

            self.add_point_from_network({'x': x, 'y': y, 'z': z}) 

            # Clear the input fields for the next entry. 

            self.input_x.clear() 

            self.input_y.clear() 

            self.input_z.clear() 

        except ValueError: 

            QMessageBox.warning(self, "Input Error", "Please enter valid numeric coordinates.") 

 
 

    def init_gl(self): 

        """Initializes or resets the 3D view.""" 

        self.gl_view.clear() 

        grid = gl.GLGridItem() 

        grid.setSize(20, 20), grid.setSpacing(1, 1), grid.translate(0, 0, 0) 

        self.gl_view.addItem(grid) 

        # Keep track of all plotted items so they can be cleared later. 

        self.point_items, self.line_items, self.predicted_point_items, self.predicted_line_items = [], [], [], [] 

 
 

    def add_sphere(self, pos, color=QColor(0, 255, 0), radius=0.3): 

        """Creates and adds a 3D sphere to the plot.""" 

        md = gl.MeshData.sphere(rows=10, cols=10, radius=radius) 

        m = gl.GLMeshItem(meshdata=md, smooth=True, color=color, shader='shaded', glOptions='opaque') 

        m.translate(*pos) 

        self.gl_view.addItem(m) 

        return m 

 
 

    def on_clear_all(self): 

        """Clears all data and visual elements from the plot and lists.""" 

        self.points.clear() 

        self.predicted_points.clear() 

        self.list_points.clear() 

        for item in self.point_items + self.line_items + self.predicted_point_items + self.predicted_line_items: 

            self.gl_view.removeItem(item) 

        self.point_items.clear(), self.line_items.clear() 

        self.predicted_point_items.clear(), self.predicted_line_items.clear() 

 
 

    def on_show_trajectory(self): 

        """Draws lines connecting all the tracked points.""" 

        # Remove any old trajectory lines first. 

        for line in self.line_items: 

            self.gl_view.removeItem(line) 

        self.line_items.clear() 

        # Need at least two points to draw a line. 

        if len(self.points) > 1: 

            # `np.vstack` stacks the points into a format pyqtgraph understands for a continuous line. 

            pts = np.vstack(self.points) 

            line = gl.GLLinePlotItem(pos=pts, color=(0,0,1,1), width=2, antialias=True) 

            self.gl_view.addItem(line) 

            self.line_items.append(line) 

 
 

    def on_predict_path(self): 

        """Performs a simple quadratic prediction based on the last 3 points.""" 

        if len(self.points) < 3: 

            QMessageBox.information(self, "Info", "Need at least 3 points for prediction.") 

            return 

        # Clear old prediction visuals. 

        for p in self.predicted_point_items + self.predicted_line_items: 

            self.gl_view.removeItem(p) 

        self.predicted_point_items.clear(), self.predicted_line_items.clear() 

         

        # Perform polynomial fitting for each axis (x, y, z) independently. 

        last_pts = np.array(self.points[-3:]) 

        t = np.array([0, 1, 2]) 

        coeffs_x = np.polyfit(t, last_pts[:,0], 2) 

        coeffs_y = np.polyfit(t, last_pts[:,1], 2) 

        coeffs_z = np.polyfit(t, last_pts[:,2], 2) 

        prev = last_pts[-1] 

         

        # Generate and plot the next 10 predicted points. 

        for ti in range(3, 13): 

            pred = np.array([np.polyval(coeffs_x, ti), np.polyval(coeffs_y, ti), np.polyval(coeffs_z, ti)]) 

            sphere = self.add_sphere(pred, QColor(135,206,250), 0.2) 

            self.predicted_point_items.append(sphere) 

            line = gl.GLLinePlotItem(pos=np.vstack([prev, pred]), color=(0.53, 0.81, 0.92, 1), width=2, antialias=True) 

            self.gl_view.addItem(line) 

            self.predicted_line_items.append(line) 

            prev = pred 

 
 

    def closeEvent(self, event): 

        """ 

        This method is called when the user closes the window. 

        It ensures the background thread is properly shut down. 

        """ 

        print("Closing application and stopping client thread.") 

        # `quit()` tells the thread's event loop to exit. 

        self.client_thread.quit() 

        # `wait()` pauses the main thread until the background thread has fully terminated. 

        self.client_thread.wait() 

        event.accept() 

 
 

# The standard entry point for a Python script. 

if __name__ == "__main__": 

    app = QApplication(sys.argv) 

    window = SatelliteTracker3D() 

    signal.signal(signal.SIGINT, signal.SIG_DFL)

    window.show() 

    sys.exit(app.exec()) 

 
 

 
